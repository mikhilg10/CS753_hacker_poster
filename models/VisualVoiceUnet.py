# -*- coding: utf-8 -*-
"""asr_hacker.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FfOfHGpo6YMekcWvS_4cboGoYrx4g8mZ
"""

import torch
import torch.nn as nn
import torchvision
from torchvision import models
import torch.nn.functional as F



class UpCon(nn.Module):
  def __init__(self,in_chan,out_chan):
    super(UpCon,self).__init__()
    self.con = nn.Sequential(nn.Upsample(scale_factor=(2.,1.)),
                             nn.ConvTranspose2d(in_chan, out_chan, kernel_size=4, stride=2, padding=1),
                             nn.ReLU(True),
                             nn.BatchNorm2d(out_chan)
                             )
    def forward(self,x):
      return self.con(x)

a = torch.rand(1,1,128,128)
s = nn.MaxPool2d([2,1]) #nn.Upsample(scale_factor=(2.,1.))
s(a).shape

class DoubleConv(nn.Module):
  def __init__(self,in_chan,out_chan):
    super(DoubleConv,self).__init__()
    self.conv  =  nn.Sequential(
        nn.Conv2d(in_chan,out_chan,kernel_size=3,padding=1),
        nn.BatchNorm2d(out_chan),
        nn.LeakyReLU(inplace=True),
        nn.Conv2d(out_chan,out_chan,kernel_size=3,padding=1),
        nn.BatchNorm2d(out_chan),
        nn.LeakyReLU(inplace=True)
    )
  def forward(self,x):
    x = self.conv(x)
    return x

class Conv(nn.Module):
  def __init__(self,in_chan,out_chan):
    super(Conv,self).__init__()
    self.conv = nn.Sequential(nn.Conv2d(in_chan, out_chan, kernel_size=4, stride=2, padding=1),
                              nn.BatchNorm2d(out_chan),
                              nn.LeakyReLU(0.2, True)
                              )
    def forward(self,x):
      return self.conv(x)

class VisualVoiceUnet(nn.Module):
  def __init__(self,in_chan=2,out_chan=2,VD=1152,feature = [64,128,256,512,1024]):

    self.enc1 = Conv(in_chan,out_chan) # 2 64
    self.enc2 = Conv(out_chan,feature[1]) #64 128
    self.enc3 = DoubleConv(feature[1],feature[2]) #128 256
    self.enc4 = DoubleConv(feature[2],feature[3]) #256 512
    self.enc5 = DoubleConv(feature[3],feature[3]) #512 512
    self.enc6 = DoubleConv(feature[3],feature[3]) # 512 512
    self.enc7 = DoubleConv(feature[3],feature[3]) #512 512
    self.enc8 = DoubleConv(feature[3],feature[3]) #512 512

    self.dec1 = UpCon(VD,feature[3]) #1152 512
    self.dec2 = UpCon(feature[3]+feature[3],feature[3]) #1024 512
    self.dec3 = UpCon(feature[3]+feature[3],feature[3]) #1024 512
    self.dec4 = UpCon(feature[3]+feature[3],feature[3]) #1024 512
    self.dec5 = UpCon(feature[3]+feature[3],feature[2]) #1024 256
    self.dec6 = UpCon(feature[2]+feature[2],feature[1]) #512 256
    self.dec7 = nn.Sequential(nn.ConvTranspose2d(feature[1]+feature[1],feature[0], kernel_size=4, stride=2, padding=1),
                              nn.BatchNorm2d(feature[0]),
                              nn.ReLU(True)
                              )
    self.dec8 = nn.Sequential(nn.ConvTranspose2d(feature[0]+feature[0],out_chan, kernel_size=4, stride=2, padding=1),
                          nn.Sigmoid()
                          )

    self.freq_supress = nn.MaxPool2d([2,1]) #supresssing the freq dimention of the sftf


  def forward(self,x,visual):
    ac1 = self.enc1(x)
    ac2 = self.enc2(ac1)
    ac3 = self.enc3(ac2)
    ac4 = self.freq_supress(self.enc4(ac3))
    ac5 = self.freq_supress(self.enc5(ac4))
    ac6 = self.freq_supress(self.enc6(ac5))
    ac7 = self.freq_supress(self.enc7(ac6))
    ac8 = self.freq_supress(self.enc8(ac7))

    de1 = self.dec1(torch.cat((ac8,visual),dim=1))
    de2 = self.dec2(torch.cat((de1,ac7),dim=1))
    de3 = self.dec3(torch.cat((de2,ac6),dim=1))
    de4 = self.dec4(torch.cat((de3,ac5),dim=1))
    de5 = self.dec5(torch.cat((de4,ac4),dim=1))
    de6 = self.dec6(torch.cat((de5,ac3),dim=1))
    de7 = self.dec7(torch.cat((de6,ac2),dim=1))
    out = self.dec8(torch.cat((de7,ac1),dim=1))
    return out #prediction_mask

#facial attributes

# class FacialFeatures(nn.Module):
#   def __init__(self):
#     super(FacialFeatures,self).__init__()

# import torchvision.models as models
# resnet18 = models.resnet18(pretrained=True)

# resnet18

